# Malnati/git-report-ops@v1.2.0
name: "Git Report Ops"
description: "Engine GitOps v1.2.0: Modularidade granular para debug preciso de assinatura e hist√≥rico."
author: "Ricardo Malnati"

branding:
  icon: "git-pull-request"
  color: "blue"

inputs:
  token:
    description: "GitHub token."
    required: true
  report_file:
    description: "Arquivo Markdown para publicar."
    required: true
  scan_extensions:
    description: "Extens√µes para assinatura."
    required: false
    default: "ts|js|jsx|tsx|java|py|go|cs|php|sh|json|yaml|yml"
  scan_exclude:
    description: "Caminhos ignorados."
    required: false
    default: "node_modules|dist|build|.git|.github"
  report_branch_prefix:
    description: "Prefixo da branch."
    required: false
    default: "audit/report"
  pr_title:
    description: "T√≠tulo da PR."
    required: false
    default: "üõ°Ô∏è Automated Audit Report"
  pr_body:
    description: "Corpo base da PR."
    required: false
    default: "Relat√≥rio de auditoria gerado automaticamente."
  bot_email:
    description: "Email do bot."
    required: false
    default: "git-report-ops@users.noreply.github.com"
  pr_template_path:
    description: "Caminho para um template Markdown customizado."
    required: false
    default: ""

outputs:
  pr_url:
    description: "URL da Pull Request."
    value: ${{ steps.publish.outputs.pr_url }}
  status:
    description: "Status da opera√ß√£o."
    value: ${{ steps.logic_controller.outputs.status }}

runs:
  using: "composite"
  steps:
    # ==================================================================
    # BLOCK 1: INITIALIZATION & VALIDATION
    # ==================================================================
    
    # 1.0 - Valida√ß√£o de Seguran√ßa
    - id: validate_token
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
      run: |
        echo "::group::üîê Validation: Token"
        if [ -z "$TOKEN" ]; then 
           echo "‚ùå Error: Input 'token' is missing."
           exit 1
        fi
        echo "‚úÖ Token present."
        echo "::endgroup::"

    # 1.1 - Valida√ß√£o de Arquivo (Input)
    - id: validate_report
      shell: bash
      env:
        REPORT: ${{ inputs.report_file }}
      run: |
        echo "::group::üìÑ Validation: Report File"
        if [ ! -f "$REPORT" ]; then 
           echo "‚ùå Error: Report file not found at: '$REPORT'"
           exit 1
        fi
        echo "‚úÖ Report file found."
        echo "::endgroup::"

    # 1.2 - Configura√ß√£o de Ambiente Git
    - id: git_config
      shell: bash
      env:
        BOT_EMAIL: ${{ inputs.bot_email }}
      run: |
        echo "::group::üîß Git Config: Identity"
        git config user.name "git-report-ops-bot"
        git config user.email "$BOT_EMAIL"
        echo "‚úÖ Identity configured ($BOT_EMAIL)."
        echo "::endgroup::"

    # ==================================================================
    # BLOCK 2: CIRCUIT BREAKER (ANTI-LOOP)
    # ==================================================================

    # 2.0 - Prote√ß√£o por Nome da Branch
    - id: check_branch
      shell: bash
      env:
        HEAD_REF: ${{ github.head_ref }}
        PREFIX: ${{ inputs.report_branch_prefix }}
      run: |
        echo "::group::üõ°Ô∏è Anti-Loop: Branch Name"
        if [[ "$HEAD_REF" == "$PREFIX"* ]]; then
           echo "üõë Loop Detected: Inside report branch."
           echo "skip=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_LOOP" >> "$GITHUB_OUTPUT"
        else
           echo "‚úÖ Branch OK."
           echo "skip=false" >> "$GITHUB_OUTPUT"
        fi
        echo "::endgroup::"

    # 2.1 - Prepara√ß√£o do Hist√≥rico (Check R√°pido)
    - id: fetch_context
      if: steps.check_branch.outputs.skip != 'true'
      shell: bash
      env:
        HEAD_REF: ${{ github.head_ref }}
      run: |
        echo "::group::üìö Git History: Context Check"
        if [ -f .git/shallow ]; then
           echo "‚öôÔ∏è Shallow repo detected. Fetching depth 1 for author check..."
           git fetch --depth=1 origin "$HEAD_REF" 2>/dev/null || true
        fi
        echo "‚úÖ Context fetched."
        echo "::endgroup::"

    # 2.2 - Prote√ß√£o por Autor do Commit
    - id: check_author
      if: steps.check_branch.outputs.skip != 'true'
      shell: bash
      env:
        BOT_EMAIL: ${{ inputs.bot_email }}
      run: |
        echo "::group::üõ°Ô∏è Anti-Loop: Commit Author"
        LAST_AUTHOR=$(git log -1 --pretty=format:'%ae')
        
        if [[ "$LAST_AUTHOR" == "$BOT_EMAIL" ]]; then
           echo "üõë Loop Detected: Last commit by bot."
           echo "skip=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_LOOP" >> "$GITHUB_OUTPUT"
        else
           echo "‚úÖ Author OK."
           echo "skip=false" >> "$GITHUB_OUTPUT"
        fi
        echo "::endgroup::"

    # ==================================================================
    # BLOCK 3: IDEMPOTENCY CHECK
    # ==================================================================

    # 3.0 - Descoberta de Arquivos (File Discovery)
    # Lista arquivos, aplica filtros e gera lista limpa para hash
    - id: file_discovery
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true'
      shell: bash
      env:
        EXTS: ${{ inputs.scan_extensions }}
        EXCLUDE: ${{ inputs.scan_exclude }}
      run: |
        echo "::group::üßÆ Idempotency: File Discovery"
        set -euo pipefail
        
        ALL_FILES="/tmp/files_all.txt"
        FINAL_LIST="/tmp/files_to_hash.txt"
        
        # 1. Listar tudo
        git ls-tree -r HEAD --name-only > "$ALL_FILES"
        
        # 2. Filtrar e Excluir
        grep -E "\.($EXTS)$" "$ALL_FILES" | grep -vE "$EXCLUDE" > "$FINAL_LIST" || true
        
        COUNT=$(wc -l < "$FINAL_LIST")
        echo "‚úÖ Found $COUNT files matching criteria."
        
        # Exporta caminho da lista para o pr√≥ximo passo
        echo "file_list=$FINAL_LIST" >> "$GITHUB_OUTPUT"
        echo "file_count=$COUNT" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # 3.1 - C√°lculo Matem√°tico (Signature Calculation)
    # L√™ a lista de arquivos e gera o hash MD5 √∫nico
    - id: calc_signature
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true'
      shell: bash
      env:
        FILE_LIST: ${{ steps.file_discovery.outputs.file_list }}
        COUNT: ${{ steps.file_discovery.outputs.file_count }}
      run: |
        echo "::group::üßÆ Idempotency: Signature Calculation"
        set -euo pipefail
        
        if [ "$COUNT" -eq "0" ]; then
           SIGNATURE="empty"
        else
           # xargs -a l√™ do arquivo gerado no passo anterior
           xargs -a "$FILE_LIST" -d '\n' -r git hash-object > /tmp/hashes.txt
           SIGNATURE=$(md5sum /tmp/hashes.txt | awk '{print $1}')
        fi

        echo "CODE_SIGNATURE=$SIGNATURE" >> "$GITHUB_ENV"
        echo "üîë Signature: $SIGNATURE"
        echo "::endgroup::"

    # 3.2 - Prepara√ß√£o do Relat√≥rio (Metadata Injection)
    - id: prep_report
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true'
      shell: bash
      env:
        REPORT: ${{ inputs.report_file }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        SIGNATURE: ${{ env.CODE_SIGNATURE }}
      run: |
        echo "::group::üìù Report: Injecting Metadata"
        TEMP="/tmp/meta_report.md"
        echo "" > "$TEMP"
        echo "> **Content Signature:** $SIGNATURE" >> "$TEMP"
        echo "> **Source SHA:** $HEAD_SHA" >> "$TEMP"
        echo "> **Data:** $(date -u)" >> "$TEMP"
        echo "" >> "$TEMP"
        cat "$REPORT" >> "$TEMP"
        mv "$TEMP" "$REPORT"
        echo "‚úÖ Metadata added."
        echo "::endgroup::"

    # 3.3 - Prepara√ß√£o do Hist√≥rico Profundo (Fetch Deep)
    # Garante que o git tem dados para buscar no passado
    - id: fetch_deep_history
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true'
      shell: bash
      run: |
        echo "::group::üìö Idempotency: Deep Fetch"
        set -euo pipefail
        
        if [ -f .git/shallow ]; then 
           echo "‚öôÔ∏è Unshallowing repository..."
           git fetch --unshallow 2>/dev/null || true
        fi
        
        echo "üîÑ Fetching all refs..."
        git fetch --all --quiet
        echo "::endgroup::"

    # 3.4 - Busca de Assinatura (Signature Search)
    # O grep propriamente dito
    - id: search_signature
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true'
      shell: bash
      env:
        SIGNATURE: ${{ env.CODE_SIGNATURE }}
        BOT_EMAIL: ${{ inputs.bot_email }}
      run: |
        echo "::group::üïµÔ∏è Idempotency: Searching Signature"
        set -euo pipefail
        
        SEARCH="> **Content Signature:** $SIGNATURE"
        
        # Busca otimizada por autor
        FOUND=$(git grep -I -F -l "$SEARCH" $(git rev-list --all --author="$BOT_EMAIL") -- "*.md" 2>/dev/null | head -n 1 || true)

        if [ -n "$FOUND" ]; then
           echo "‚úÖ Idempotent match found: $FOUND"
           echo "found=true" >> "$GITHUB_OUTPUT"
           echo "skip=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_IDEMPOTENT" >> "$GITHUB_OUTPUT"
           
           SHA=$(echo "$FOUND" | cut -d':' -f1)
           echo "commit_sha=$SHA" >> "$GITHUB_OUTPUT"
        else
           echo "üìù No match found. New content."
           echo "found=false" >> "$GITHUB_OUTPUT"
           echo "skip=false" >> "$GITHUB_OUTPUT"
        fi
        echo "::endgroup::"

    # 3.5 - Recupera√ß√£o de URL (Se existente)
    - id: recover_url
      if: steps.search_signature.outputs.found == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        COMMIT_SHA: ${{ steps.search_signature.outputs.commit_sha }}
        PREFIX: ${{ inputs.report_branch_prefix }}
      run: |
        echo "::group::üîó Idempotency: Recovering URL"
        
        TARGET=$(git branch -r --contains "$COMMIT_SHA" | grep "$PREFIX" | head -n 1 | sed 's/^[[:space:]]*origin\///' | xargs || true)
        
        if [ -n "$TARGET" ]; then
           URL=$(gh pr list --head "$TARGET" --state open --json url -q .[0].url || true)
           if [ -n "$URL" ] && [ "$URL" != "null" ]; then
              echo "‚úÖ URL Recovered: $URL"
              echo "pr_url=$URL" >> "$GITHUB_OUTPUT"
           fi
        fi
        echo "::endgroup::"

    # ==================================================================
    # BLOCK 4: PUBLISH (BRANCH & PR)
    # ==================================================================

    # 4.0 - Opera√ß√µes Git
    - id: git_push
      # O If verifica o output do √öLTIMO passo de decis√£o (search_signature)
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true' && steps.search_signature.outputs.skip != 'true'
      shell: bash
      env:
        HEAD_REF: ${{ github.head_ref }}
        PREFIX: ${{ inputs.report_branch_prefix }}
        REPORT: ${{ inputs.report_file }}
      run: |
        echo "::group::üöÄ Git: Pushing"
        REPORT_BRANCH="${PREFIX}/${HEAD_REF}"
        git checkout "$HEAD_REF"
        git checkout -B "$REPORT_BRANCH"
        git add "$REPORT"
        git commit -m "docs: automated report update [skip ci]"
        git push -f origin "$REPORT_BRANCH"
        echo "branch=$REPORT_BRANCH" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # 4.1 - Constru√ß√£o do Corpo (Template)
    - id: build_body
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true' && steps.search_signature.outputs.skip != 'true'
      shell: bash
      env:
        PR_NUM: ${{ github.event.pull_request.number }}
        HEAD_REF: ${{ github.head_ref }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        SIGNATURE: ${{ env.CODE_SIGNATURE }}
        USER_BODY: ${{ inputs.pr_body }}
        CUSTOM_TEMPLATE: ${{ inputs.pr_template_path }}
        DEFAULT_TEMPLATE: ${{ github.action_path }}/templates/pr-body-default.md
      run: |
        echo "::group::üìù PR: Building Body"
        BODY_FILE="/tmp/pr_description.md"
        export DATE=$(date -u)
        
        if [[ -n "$CUSTOM_TEMPLATE" && -f "$CUSTOM_TEMPLATE" ]]; then
           TEMPLATE_SOURCE="$CUSTOM_TEMPLATE"
        else
           TEMPLATE_SOURCE="$DEFAULT_TEMPLATE"
        fi
        
        envsubst < "$TEMPLATE_SOURCE" > "$BODY_FILE"
        
        echo "" >> "$BODY_FILE"
        echo "" >> "$BODY_FILE"
        
        echo "body_file=$BODY_FILE" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # 4.2 - Gerenciamento da PR
    - id: publish
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true' && steps.search_signature.outputs.skip != 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        HEAD_REF: ${{ github.head_ref }}
        REPORT_BRANCH: ${{ steps.git_push.outputs.branch }}
        TITLE: ${{ inputs.pr_title }}
        BODY_FILE: ${{ steps.build_body.outputs.body_file }}
      run: |
        echo "::group::üì° API: PR Management"
        
        gh pr create \
          --base "$HEAD_REF" \
          --head "$REPORT_BRANCH" \
          --title "$TITLE" \
          --body-file "$BODY_FILE" || true
          
        PR_URL=$(gh pr view "$REPORT_BRANCH" --json url -q .url)
        gh pr edit "$PR_URL" --body-file "$BODY_FILE" || true
        
        echo "‚úÖ PR Link: $PR_URL"
        echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
        echo "status=PUBLISHED" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

Tem certeza que devo substituir os 3 blocos acima por este com este heredoc no template_string fugindo dos requisitos e descartando a modulariza√ß√£o anterior?
      # 4. NOTIFICA√á√ÉO (Agora usando v7)
      - name: üîî Notify User
        if: steps.ops.outputs.status == 'PUBLISHED' || steps.ops.outputs.status == 'SKIPPED_IDEMPOTENT'
        uses: Malnati/pr-comment@v7.0.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          pr_number: ${{ github.event.pull_request.number }}
          message_id: "ops-engine-report"
          
          # Template INLINE (Recurso novo da v7!)
          template_string: |
            ## ‚öôÔ∏è Git Report Ops
            
            > [!TIP]
            > **Relat√≥rio de Infraestrutura Gerado**
            > A engine processou os artefatos e publicou em uma branch dedicada.
            
            <div align="center">
            
            | üì° Status | üîó Relat√≥rio |
            | :---: | :---: |
            | **${FOOTER_RESULT}** | **[Ver Pull Request](${BODY_MESSAGE})** |
            
            </div>
            
            ---
            <div align="right"><sub>Gerado automaticamente</sub></div>
          
          # Mapeamento de Vari√°veis
          footer_result: ${{ steps.ops.outputs.status == 'PUBLISHED' && '‚úÖ Atualizado' || '‚è∏Ô∏è Sem Mudan√ßas' }}
          body_message: ${{ steps.ops.outputs.pr_url }}
          
    # ==================================================================
    # BLOCK 5: CONTROLLER (OUTPUT SUMMARY)
    # ==================================================================
    - id: logic_controller
      shell: bash
      if: always()
      env:
        # Circuit Breakers
        S_BRANCH: ${{ steps.check_branch.outputs.reason }}
        S_AUTHOR: ${{ steps.check_author.outputs.reason }}
        # Idempotency
        S_IDEM: ${{ steps.search_signature.outputs.reason }}
        # Publication
        S_PUB: ${{ steps.publish.outputs.status }}
        # URLs
        URL_REC: ${{ steps.recover_url.outputs.pr_url }}
        URL_PUB: ${{ steps.publish.outputs.pr_url }}
      run: |
        # Prioridade de Status (Quem definiu o estado final?)
        if [ -n "$S_PUB" ]; then FINAL_STATUS="$S_PUB";
        elif [ -n "$S_IDEM" ]; then FINAL_STATUS="$S_IDEM";
        elif [ -n "$S_AUTHOR" ]; then FINAL_STATUS="$S_AUTHOR";
        elif [ -n "$S_BRANCH" ]; then FINAL_STATUS="$S_BRANCH";
        else FINAL_STATUS="UNKNOWN"; fi
        
        # Prioridade de URL
        if [ -n "$URL_PUB" ]; then FINAL_URL="$URL_PUB";
        else FINAL_URL="$URL_REC"; fi

        echo "status=$FINAL_STATUS" >> "$GITHUB_OUTPUT"
        echo "pr_url=$FINAL_URL" >> "$GITHUB_OUTPUT"
