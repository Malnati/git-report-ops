# Malnati/git-report-ops@v1.2.0
name: "Git Report Ops"
description: "Engine GitOps v1.2.0: GestÃ£o de relatÃ³rios baseada estritamente em arquivos (No Heredoc)."
author: "Ricardo Malnati"

branding:
  icon: "git-pull-request"
  color: "blue"

inputs:
  token:
    description: "GitHub token."
    required: true
  
  # 1. O ConteÃºdo Principal
  report_file:
    description: "Caminho do arquivo Markdown gerado pela ferramenta de anÃ¡lise."
    required: true
  
  # 2. Templates (Arquivos ObrigatÃ³rios/Opcionais)
  pr_body_template:
    description: "Caminho do template para o Corpo da PR de RelatÃ³rio (PR B)."
    required: false
    default: "" 
    # Se vazio, usa um default interno (mas via arquivo cp, nÃ£o echo)
  
  # 3. ConfiguraÃ§Ã£o Git
  report_branch_prefix:
    description: "Prefixo da branch."
    required: false
    default: "audit/report"
  pr_title:
    description: "TÃ­tulo da PR de RelatÃ³rio."
    required: false
    default: "ðŸ›¡ï¸ Automated Audit Report"
  bot_email:
    description: "Email do bot."
    required: false
    default: "git-report-ops@users.noreply.github.com"
    
  # 4. Assinatura
  scan_extensions:
    description: "ExtensÃµes para assinatura."
    required: false
    default: "ts|js|jsx|tsx|java|py|go|cs|php|sh|json|yaml|yml"
  scan_exclude:
    description: "Caminhos ignorados."
    required: false
    default: "node_modules|dist|build|.git|.github"

outputs:
  pr_url:
    description: "URL da Pull Request de RelatÃ³rio."
    value: ${{ steps.publish.outputs.pr_url }}
  status:
    description: "Status da operaÃ§Ã£o (PUBLISHED, SKIPPED...)."
    value: ${{ steps.controller.outputs.status }}

runs:
  using: "composite"
  steps:
    # ==================================================================
    # BLOCK 1: SETUP & VALIDATION
    # ==================================================================
    - id: setup
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPORT: ${{ inputs.report_file }}
      run: |
        echo "::group::ðŸ”§ Setup"
        if [ -z "$TOKEN" ]; then echo "âŒ Token missing."; exit 1; fi
        if [ ! -f "$REPORT" ]; then echo "âŒ Report file missing: $REPORT"; exit 1; fi
        
        # Configura git
        git config user.name "git-report-ops-bot"
        git config user.email "${{ inputs.bot_email }}"
        echo "âœ… Setup complete."
        echo "::endgroup::"

    # ==================================================================
    # BLOCK 2: CIRCUIT BREAKER & PERMS
    # ==================================================================
    - id: check_environment
      shell: bash
      env:
        HEAD_REF: ${{ github.head_ref }}
        PREFIX: ${{ inputs.report_branch_prefix }}
        BOT_EMAIL: ${{ inputs.bot_email }}
      run: |
        echo "::group::ðŸ›¡ï¸ Circuit Breaker"
        
        # 1. Branch Check
        if [[ "$HEAD_REF" == "$PREFIX"* ]]; then
           echo "ðŸ›‘ Loop: Inside report branch."
           echo "skip=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_LOOP" >> "$GITHUB_OUTPUT"
           exit 0
        fi
        
        # 2. Author Check
        if [ -f .git/shallow ]; then git fetch --depth=1 origin "$HEAD_REF" 2>/dev/null || true; fi
        LAST=$(git log -1 --pretty=format:'%ae')
        
        if [[ "$LAST" == "$BOT_EMAIL" ]]; then
           echo "ðŸ›‘ Loop: Bot commit detected."
           echo "skip=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_LOOP" >> "$GITHUB_OUTPUT"
           exit 0
        fi
        
        echo "âœ… Safe to proceed."
        echo "skip=false" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # ==================================================================
    # BLOCK 3: IDEMPOTENCY (FILE BASED)
    # ==================================================================
    - id: calc_signature
      if: steps.check_environment.outputs.skip != 'true'
      shell: bash
      env:
        EXTS: ${{ inputs.scan_extensions }}
        EXCLUDE: ${{ inputs.scan_exclude }}
      run: |
        echo "::group::ðŸ§® Signature Calculation"
        set -euo pipefail
        
        # Arquivos temporÃ¡rios para lista
        LIST_FILE="/tmp/file_list.txt"
        
        git ls-tree -r HEAD --name-only \
          | grep -E "\.($EXTS)$" \
          | grep -vE "$EXCLUDE" > "$LIST_FILE" || true
          
        if [ -s "$LIST_FILE" ]; then
           xargs -a "$LIST_FILE" -d '\n' -r git hash-object > /tmp/hashes.txt
           SIGNATURE=$(md5sum /tmp/hashes.txt | awk '{print $1}')
        else
           SIGNATURE="empty"
        fi
        
        echo "CODE_SIGNATURE=$SIGNATURE" >> "$GITHUB_ENV"
        echo "ðŸ”‘ Signature: $SIGNATURE"
        echo "::endgroup::"

    - id: check_history
      if: steps.check_environment.outputs.skip != 'true'
      shell: bash
      env:
        SIGNATURE: ${{ env.CODE_SIGNATURE }}
        BOT_EMAIL: ${{ inputs.bot_email }}
      run: |
        echo "::group::ðŸ•µï¸ History Search"
        
        if [ -f .git/shallow ]; then git fetch --unshallow 2>/dev/null || true; fi
        git fetch --all --quiet
        
        SEARCH="> **Content Signature:** $SIGNATURE"
        FOUND=$(git grep -I -F -l "$SEARCH" $(git rev-list --all --author="$BOT_EMAIL") -- "*.md" 2>/dev/null | head -n 1 || true)

        if [ -n "$FOUND" ]; then
           echo "âœ… Idempotent match: $FOUND"
           echo "found=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_IDEMPOTENT" >> "$GITHUB_OUTPUT"
           
           SHA=$(echo "$FOUND" | cut -d':' -f1)
           echo "commit_sha=$SHA" >> "$GITHUB_OUTPUT"
        else
           echo "found=false" >> "$GITHUB_OUTPUT"
        fi
        echo "::endgroup::"

    - id: recover_url
      if: steps.check_history.outputs.found == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        COMMIT_SHA: ${{ steps.check_history.outputs.commit_sha }}
        PREFIX: ${{ inputs.report_branch_prefix }}
      run: |
        TARGET=$(git branch -r --contains "$COMMIT_SHA" | grep "$PREFIX" | head -n 1 | sed 's/origin\///' | xargs || true)
        if [ -n "$TARGET" ]; then
           URL=$(gh pr list --head "$TARGET" --state open --json url -q .[0].url || true)
           [ -n "$URL" ] && echo "pr_url=$URL" >> "$GITHUB_OUTPUT"
        fi

    # ==================================================================
    # BLOCK 4: PREPARE CONTENT (TEMPLATES ON DISK)
    # ==================================================================
    - id: prepare_files
      if: steps.check_environment.outputs.skip != 'true' && steps.check_history.outputs.found != 'true'
      shell: bash
      env:
        # VariÃ¡veis para o envsubst
        PR_NUM: ${{ github.event.pull_request.number }}
        HEAD_REF: ${{ github.head_ref }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        SIGNATURE: ${{ env.CODE_SIGNATURE }}
        # Arquivos
        REPORT: ${{ inputs.report_file }}
        USER_TEMPLATE: ${{ inputs.pr_body_template }}
        DEFAULT_TEMPLATE: ${{ github.action_path }}/templates/pr-body-default.md
      run: |
        echo "::group::ðŸ“ Content Preparation"
        set -euo pipefail
        
        export DATE=$(date -u)
        
        # 1. Injeta Metadata no RelatÃ³rio (Arquivo FÃ­sico)
        META_FILE="/tmp/metadata_header.md"
        # Cria o arquivo sem heredoc, linha por linha
        echo "" > "$META_FILE"
        echo "> **Content Signature:** $SIGNATURE" >> "$META_FILE"
        echo "> **Source SHA:** $HEAD_SHA" >> "$META_FILE"
        echo "> **Data:** $DATE" >> "$META_FILE"
        echo "" >> "$META_FILE"
        
        # Concatena: Metadata + RelatÃ³rio Original -> Novo RelatÃ³rio
        cat "$META_FILE" "$REPORT" > "/tmp/final_report.md"
        mv "/tmp/final_report.md" "$REPORT"
        echo "âœ… Report file ready."

        # 2. Prepara o Corpo da PR (PR B)
        PR_BODY_FILE="/tmp/pr_b_body.md"
        
        if [[ -n "$USER_TEMPLATE" && -f "$USER_TEMPLATE" ]]; then
           SRC_TEMPLATE="$USER_TEMPLATE"
        else
           SRC_TEMPLATE="$DEFAULT_TEMPLATE"
        fi
        
        # Processa template e adiciona assinatura oculta no final
        envsubst < "$SRC_TEMPLATE" > "$PR_BODY_FILE"
        echo "" >> "$PR_BODY_FILE"
        echo "" >> "$PR_BODY_FILE"
        
        echo "âœ… PR Body file ready at $PR_BODY_FILE"
        echo "pr_body_file=$PR_BODY_FILE" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # ==================================================================
    # BLOCK 5: PUBLISH (GIT & API)
    # ==================================================================
    - id: publish
      if: steps.check_environment.outputs.skip != 'true' && steps.check_history.outputs.found != 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        HEAD_REF: ${{ github.head_ref }}
        PREFIX: ${{ inputs.report_branch_prefix }}
        REPORT: ${{ inputs.report_file }}
        TITLE: ${{ inputs.pr_title }}
        BODY_FILE: ${{ steps.prepare_files.outputs.pr_body_file }}
      run: |
        echo "::group::ðŸš€ Publishing"
        set -euo pipefail
        
        REPORT_BRANCH="${PREFIX}/${HEAD_REF}"
        
        # Git Push
        git checkout "$HEAD_REF"
        git checkout -B "$REPORT_BRANCH"
        git add "$REPORT"
        git commit -m "docs: automated report update [skip ci]"
        git push -f origin "$REPORT_BRANCH"
        
        # Create PR
        gh pr create \
          --base "$HEAD_REF" \
          --head "$REPORT_BRANCH" \
          --title "$TITLE" \
          --body-file "$BODY_FILE" || true
          
        PR_URL=$(gh pr view "$REPORT_BRANCH" --json url -q .url)
        
        # Update PR Body (Garante atualizaÃ§Ã£o)
        gh pr edit "$PR_URL" --body-file "$BODY_FILE" || true
        
        echo "âœ… PR: $PR_URL"
        echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
        echo "status=PUBLISHED" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # ==================================================================
    # BLOCK 6: CONTROLLER
    # ==================================================================
    - id: controller
      shell: bash
      if: always()
      env:
        S1: ${{ steps.check_environment.outputs.reason }}
        S2: ${{ steps.check_history.outputs.reason }}
        S3: ${{ steps.publish.outputs.status }}
        URL1: ${{ steps.recover_url.outputs.pr_url }}
        URL2: ${{ steps.publish.outputs.pr_url }}
      run: |
        if [ -n "$S3" ]; then STATUS="$S3";
        elif [ -n "$S2" ]; then STATUS="$S2";
        elif [ -n "$S1" ]; then STATUS="$S1";
        else STATUS="UNKNOWN"; fi
        
        if [ -n "$URL2" ]; then URL="$URL2"; else URL="$URL1"; fi

        echo "status=$STATUS" >> "$GITHUB_OUTPUT"
        echo "pr_url=$URL" >> "$GITHUB_OUTPUT"
